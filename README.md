# Java_Sping_Shop_Practice
2022.02 ~ 2022.05

자바 스프링과 타임리프를 이용하여 쇼핑몰을 만들며 공부하고 있습니다.

## 환경 구성

템플릿 엔진 -> thymeleaf    
데이터베이스 -> H2

## 도메인 요구사항

```
회원기능
    -> 회원가입
    -> 회원목록

상품기능
    -> 상품등록
    -> 상품수정
    -> 상품조회

주문기능
    -> 상품주문
    -> 주문내역조회
    -> 주문취소

기타요구사항
    -> 상품은 제고 관리가 필요하다.
    -> 상품의 종류는 도서, 음반, 영화가 있다.
    -> 상품을 카테고리로 구분할 수 있다.
    -> 상품 주문시 배송 정보를 입력할 수 있다.
```


## 도메인 모델과 테이블 설계

![image](https://user-images.githubusercontent.com/41615081/208393284-d442b4cf-1623-43aa-a077-4d6d8dee694a.png)

```
회원은 여러개의 주문을 할 수 있으므로 회원:주문 -> 1:N 관계이다.   
   
하나의 주문에 여러 상품이 담길 수 있고 하나의 상품도 여러 주문에 포함될 수 있므르로 N:N 관계를 풀기 위해서 중간에 주문상품 테이블을 넣어서 1:N 2개로 만들었다.   
   
주문마다 배송 정보가 담기므로 주문:배송 -> 1:1 관계이다.   
   
상품은 3가지 타입으로 나뉜다.   
   
하나의 카테고리에 여러 상품이 포함되고 하나의 상품이 여러 카테고리에 포함될 수 있으므로 카테고리:상품 -> N:N 관계이다.   
```
   
## 회원 엔티티 분석

![image](https://user-images.githubusercontent.com/41615081/208393698-0b44101a-cdbe-429f-8d17-c9f2a7f21d34.png)
 
```
회원(Member): 이름과 임베디드 타입인 Address, 그리고 orders 리스트를 가진다.

주문(Order): 한 번 주문시 여러 상품을 주문할 수 있으므로 주문과 주문상품( OrderItem )은 일대다 관계다. 주문은 상품을 주문한 회원과 배송 정보, 주문 날짜, 주문 상태( status )를 가지고 있다. 주문 상태는 열거형을 사용했는데 주문( ORDER ), 취소( CANCEL )을 표현할 수 있다.

주문상품(OrderItem): 주문한 상품 정보와 주문 금액( orderPrice ), 주문 수량( count ) 정보를 가지고 있다. (보통 OrderLine , LineItem 으로 많이 표현한다.)

상품(Item): 이름, 가격, 재고수량( stockQuantity )을 가지고 있다. 상품을 주문하면 재고수량이 줄어든다. 상품의 종류로는 도서, 음반, 영화가 있는데 각각은 사용하는 속성이 조금씩 다르다.

배송(Delivery): 주문시 하나의 배송 정보를 생성한다. 주문과 배송은 일대일 관계다.

카테고리(Category): 상품과 다대다 관계를 맺는다. parent , child 로 부모, 자식 카테고리를 연결한 다.

주소(Address): 값 타입(임베디드 타입)이다. 회원과 배송(Delivery)에서 사용한다.
```

## 회원 테이블 분석

![image](https://user-images.githubusercontent.com/41615081/208393856-4fa3c294-e012-4d4d-a20a-14c92b91333b.png)

```
MEMBER: 회원 엔티티의 Address 임베디드 타입 정보가 회원 테이블에 그대로 들어갔다. 이것은 DELIVERY 테이블도 마찬가지다.

ITEM: 앨범, 도서, 영화 타입을 통합해서 하나의 테이블로 만들었다. -> 싱글 테이블 전략

DTYPE 컬럼으로 타입을 구분한다

카테고리는 객체에서는 다대다 관계가 가능하지만 관계형 데이터베이스에서는 다대다 관계가 불가능하므로 중간에 CATEGORY_ITEM이라는 맵핑 테이블을 추가했다.
```


 

## 연관관계 매핑 분석

```
회원과 주문: 일대다, 다대일의 양방향 관계다. 따라서 연관관계의 주인을 정해야 하는데, 외래 키가 있는 주문을 연관관계의 주인으로 정하는 것이 좋다. 그러므로 Order.member를 ORDERS.MEMBER_ID 외래 키와 매핑한다.

주문상품과 주문: 다대일 양방향 관계다. 외래 키가 주문상품에 있으므로 주문상품이 연관관계의 주인이다. 그러므로 OrderItem.order 를 ORDER_ITEM.ORDER_ID 외래 키와 매핑한다.

주문상품과 상품: 다대일 단방향 관계다. OrderItem.item 을 ORDER_ITEM.ITEM_ID 외래 키와 매핑한다.

주문과 배송: 일대일 양방향 관계다. Order.delivery 를 ORDERS.DELIVERY_ID 외래 키와 매핑한다.

카테고리와 상품: @ManyToMany 를 사용해서 매핑한다.(실무에서 @ManyToMany는 사용하지 말자. 여기 서는 다대다 관계를 예제로 보여주기 위해 추가했을 뿐이다)
```

## 엔티티 클래스 개발시 주의점
```
1. Getter는 기본적으로 열어두는 것이 편하지만 Setter는 데이터가 변할 수 있기 때문에 엔티티를 변경할 때는 Setter 대신에 데이터를 변경하기 위한 비즈니스 메소드를 별도로 제공해야한다. 변경 포인트는 최소화하자.

2. @ManyToMany는 사용하면 안된다.

3. 모든 연관관계는 즉시로딩(Eager)이 아닌 지연로딩(Lazy)으로 설정해야 한다. 연관된 엔티티를 함께 DB에서 조회해야 하면 fetch join 기능을 활용한다. XXXToOne은 default가 즉시로딩이다.

4. @ManyToOne, @OneToOne은 Default가 Eager이므로 모두 Lazy로 설정해야한다.
 
5. 컬렉션은 필드에서 바로 초기화하자.
->null 문제에서 안전

6. 연관관계 편의 메서드

-> 양방향 연관관계에서 양쪽 모두 set해야하는데 빼먹을 수 있으므로 연관관계 편의 메서드를 만들어서 두 개의 set을 원자적으로 묶어서 실수를 줄일 수 있다.
```

## 애플리케이션 아키텍처
![image](https://user-images.githubusercontent.com/41615081/208394209-9c152f5f-283f-403d-a05b-976d512592f0.png)

```
계층형 구조 사용

controller, web: 웹 계층
service: 비즈니스 로직, 트랜잭션 처리
repository: JPA를 직접 사용하는 계층, 엔티티 매니저 사용
domain: 엔티티가 모여 있는 계층, 모든 계층에서 사용
```
 
